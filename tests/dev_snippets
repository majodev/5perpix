templates:

<template name="">
	<div class="">
	</div>
</template>





Meteor.methods({
	foo: function (arg1, arg2) {
		check(arg1, String);
		check(arg2, [Number]);
		// .. do stuff ..
		if (you want to throw an error)
			throw new Meteor.Error(404, "Can't find my pants");
		return "some return value";
	},

	bar: function () {
		// .. do other stuff ..
		return "baz";
	}
});



Template.pictureVisualizationItemSVG.rendered = function () {
	console.log("Template.pictureVisualizationItemSVG.rendered");
	var self = this;
	self.node = self.find("svg");

	if(! self.handle) {
		
		// define a Dep.autorun for the Template, which automatically runs when changes happen
		self.handle = Deps.autorun(function (){
			console.log("Template.pictureVisualizationItemSVG.rendered: Deps.autorun");

			/**
			 * Init / Update on change
			 * @param  {svg:rect} Needs d3.js rects as parameter.
			 */
			var updateRaw = function (rect) {
			};

			// bind my pixel data to the g class .pixels 
			var minpix = d3.select(self.node).select(".pictureVisualizationItemSVGPixels").selectAll("rect")
				.data(MrtPixelCollection.find({
					picID: Session.get("selected_picture")}).fetch(), 
					function (minpix) {return minpix._id; });


			// data update only triggers fill to refresh
			updateRaw(minpix.enter().append("svg:rect"));
			
			d3.select(self.node).select(".pictureVisualizationItemSVGPixels").selectAll("rect")
				.data(MrtPixelCollection.find({picID: Session.get("selected_picture")}).fetch(), 
					function (minpix) {return minpix._id; })
				.style("fill", function(d) { return getStringEJSONColor(d.color); })
		});
	}
};



// server: publish the current size of a collection
Meteor.publish("counts-by-room", function (roomId) {
  var self = this;
  check(roomId, String);
  var count = 0;
  var initializing = true;
  var handle = Messages.find({roomId: roomId}).observeChanges({
    added: function (id) {
      count++;
      if (!initializing)
        self.changed("counts", roomId, {count: count});
    },
    removed: function (id) {
      count--;
      self.changed("counts", roomId, {count: count});
    }
    // don't care about moved or changed
  });

  // Observe only returns after the initial added callbacks have
  // run.  Now return an initial value and mark the subscription
  // as ready.
  initializing = false;
  self.added("counts", roomId, {count: count});
  self.ready();

  // Stop observing the cursor when client unsubs.
  // Stopping a subscription automatically takes
  // care of sending the client any removed messages.
  self.onStop(function () {
    handle.stop();
  });
});

// client: declare collection to hold count object
Counts = new Meteor.Collection("counts");

// client: subscribe to the count for the current room
Deps.autorun(function () {
  Meteor.subscribe("counts-by-room", Session.get("roomId"));
});

// client: use the new collection
console.log("Current room has " +
            Counts.findOne(Session.get("roomId")).count +
            " messages.");